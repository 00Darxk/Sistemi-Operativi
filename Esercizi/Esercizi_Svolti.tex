\documentclass{article}

\usepackage{cancel}
\usepackage{amsmath}
\usepackage[includehead,nomarginpar]{geometry}
\usepackage{graphicx}
\usepackage{amsfonts} 
\usepackage{verbatim}
\usepackage{mathrsfs}  
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{braket}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage{romanbarpagenumber}
\usepackage{minted}
%\usepackage{subfig}
\usepackage[italian]{babel}
%\usepackage{float}
%\usepackage{wrapfig}
%\usepackage[export]{adjustbox}
\allowdisplaybreaks

\setlength{\headheight}{12.0pt}
\addtolength{\topmargin}{-12.0pt}
\graphicspath{ {./Immagini/} }

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    pdftitle={Esercizi Svolti di Sistemi Operativi},
    pdfauthor={Giacomo Sturm}
}

\newsavebox{\tempbox} %{\raisebox{\dimexpr.5\ht\tempbox-.5\height\relax}}

\makeatother

\numberwithin{equation}{subsection}
\newcommand{\tageq}{\tag{\stepcounter{equation}\theequation}}
\AtBeginDocument{%
  \renewcommand{\figurename}{Fig.}
}
\fancypagestyle{link}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}\fancyfoot[C]{Sorgente del file LaTeX disponibile al seguente link: \url{https://github.com/00Darxk/Sistemi-Operativi}}}

\begin{document}

\title{%
    \textbf{Sistemi Operativi}  \\ 
    \large Esercizi Svolti di Sistemi Operativi \\
    \textit{Anno Accademico: 2024/25}}
\author{\textit{Giacomo Sturm}}
\date{\textit{Dipartimento di Ingegneria Civile, Informatica e delle Tecnologie Aeronautiche \\
Università degli Studi ``Roma Tre"}}

\maketitle
\thispagestyle{link}

\clearpage


\pagestyle{fancy}
\fancyhead{}\fancyfoot{}
\fancyhead[C]{\textit{Sistemi Operativi - Università degli Studi ``Roma Tre"}}
\fancyfoot[C]{\thepage}
\pagenumbering{Roman}

\tableofcontents

\clearpage
\pagenumbering{arabic}

\section{Traduzione di Indirizzi}
Questi esercizi sono stati generati con strumenti presenti nella repository \href{https://github.com/remzi-arpacidusseau/ostep-homework}{\texttt{ostep-homework}}, utilizzata anche per 
realizzare gli esercizi presenti nei quiz del corso. 


Dato un sistema con uno spazio fisico di 32K ed uno spazio degli indirizzi di 16K e pagine di dimensione 4K. Con PTE eventi il bit più significativo, il più a sinistra, 
è il bit di validità, se è 1 la traduzione è valida, altrimenti se è 0 non è valida:
\begin{itemize}
    \item \verb|0|: \verb|0x8000000c|;
    \item \verb|1|: \verb|0x00000000|;
    \item \verb|2|: \verb|0x00000000|;
    \item \verb|3|: \verb|0x80000006|.
\end{itemize}

Determinare l'indirizzo fisico dei seguenti indirizzi virtuali oppure specificare se sono invalidi:
\begin{itemize}
    \item \verb|0x00003229| (\verb|12841|);
    \item \verb|0x00001369| (\verb|4969|);
    \item \verb|0x00001e80| (\verb|7808|);
    \item \verb|0x00002556| (\verb|9558|);
    \item \verb|0x00003a1e| (\verb|14878|).
\end{itemize}

Per semplificare la procedura per determinare il valore dei bit più significativi, si vuole sapere in quale pagina è presente l'indirizzo, quindi è sufficiente determinare 
il quoziente tra l'indirizzo virtuale e la dimensione della pagina:
\begin{gather*}
    \mathrm{VPN}:\left\lfloor\displaystyle\frac{12841}{4098}\right\rfloor=3
\end{gather*}
L'offset si calcola come la posizione nella pagina di questo indirizzo calcolata come:
\begin{equation*}
    \mathrm{Offset}:12831-3*4096=553
\end{equation*}
Il PFN corrispondente è \verb|80000006|, è valido avendo il bit più significativo pari ad uno, ed ha un indirizzo fisico 6. Per cui l'indirizzo fisico corrispondente è:
\begin{equation}
    6*4096+553=25129
\end{equation}

Il secondo indirizzo $4969$ si riferisce al secondo PFN, dato che $\lfloor4969/4096\rfloor=1$. Ma questa pagina ha il bit più significativo pari a zero, quindi la traduzione 
non è valida. Allo stesso modo per l'indirizzo $7808$. L'indirizzo $9558$ si riferisce alla seconda terza pagina, anch'essa si riferisce ad un indirizzo fisico con 
il bit più significativo pari a zero, quindi neanche questa traduzione è valida. 

L'ultimo indirizzo appartiene alla quarta VPN: 

\begin{gather*}
    \mathrm{VPN}:\left\lfloor\displaystyle\frac{14878}{4096}\right\rfloor=3\\
    14878-4096*3=2590\\
    6*4096+2590=27166\tageq
\end{gather*}

\clearpage

\section{Programmazione Multiprocesso}

Esercizi alle pagine 14 e 15 del \href{https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf}{capitolo 5}, esclusa la seconda parte del 3, il numero 4 ed il numero 8.

\subsection{Esercizio 1}
Write a program that calls \verb|fork()|. Before calling \verb|fork()|, have the main process access a variable, and set its value to something. What 
value is the variabile in the child process? What happens to the variabile when both the child and parent change the value of $x$?

\inputminted[firstline=1,lastline=2]{c}{./"Esercitazione del 29-10-24"/domanda1.c}
\inputminted[firstline=8,lastline=15]{c}{./"Esercitazione del 29-10-24"/domanda1.c}

La variabile nel processo genitore e figlio ha lo stesso valore e vengono aggiornate indipendentemente tra di loro, 
allo stesso modo, poiché i due processi hanno spazi degli indirizzi diversi e nel codice non c'è distinzione 
tra processo figlio o genitore. 

\subsection{Esercizio 2}
Write a program that opens a file (with the open() system call) and then calls \verb|fork()| 
to create a new process. Can both the child and parent access the file descriptor returned 
by \verb|open()|? What happens when they are writing to the file concurrently, i.e., at the 
same time?

\inputminted[firstline=1, lastline=4]{c}{./"Esercitazione del 29-10-24"/domanda2.c}
\inputminted[firstline=13, lastline=26]{c}{./"Esercitazione del 29-10-24"/domanda2.c}

Entrambi i processi possono accedere al file \texttt{domanda2.txt} mediante lo stesso 
file descriptor, ed in base alle flag inserite nella funzione \verb|open()| possono 
sovrascrivere il contenuto con \verb|O_TRUNC|, oppure inserirlo in coda con \verb|O_APPEND|. 

Per distinguere tra il processo padre ed il processo figlio si utilizza il valore di ritorno 
di \verb|fork()| salvato nella variabile \verb|rc|, 0 se nel processo figlio, ed il PID 
del processo figlio nel genitore. 

\subsection{Esercizio 3}
Write another program using \verb|fork()|. The child process should print ``hello''; the parent process should print ``goodbye''.

\inputminted[firstline=1, lastline=4]{c}{./"Esercitazione del 29-10-24"/domanda3.c}
\inputminted[firstline=9, lastline=16]{c}{./"Esercitazione del 29-10-24"/domanda3.c}

\subsection{Esercizio 5}

Now write a program that uses \verb|wait()| to wait for the child process to finish in the parent. What does 
\verb|wait()| return? What happens if you use \verb|wait()| in the child?


\inputminted[firstline=1, lastline=4]{c}{./"Esercitazione del 29-10-24"/domanda5.c}
\inputminted[firstline=11, lastline=19]{c}{./"Esercitazione del 29-10-24"/domanda5.c}

La chiamata di sistema \verb|wait()| restituisce un intero corrispondente al PID del figlio 
che ha aspettato. Prende come parametro un puntatore ad uno stato del processo da aspettare, 
di default, quindi con \verb|NULL| aspetta la sua terminazione. Se viene chiamato su un 
processo che non presenta figli, come il processo figlio in questo caso, termina la chiamata termina istantaneamente. 

\subsection{Esercizio 6}

Write a slight modification of the previous program, this time using \verb|waitpid()| instead of \verb|wait()|. 
When would \verb|waitpid()| be useful?

\inputminted[firstline=1, lastline=4]{c}{./"Esercitazione del 29-10-24"/domanda6.c}
\inputminted[firstline=10, lastline=19]{c}{./"Esercitazione del 29-10-24"/domanda6.c}

La funzione \verb|waitpid()| sarebbe più utile in caso fosse presente più di un processo figlio 
e si volesse attendere la terminazione di uno di questi in particolare. Come 
la \verb|wait()| il secondo argomento è un puntatore ad un intero dove inserirà lo 
stato del processo figlio terminato, il primo argomento è un intero e rappresenta il 
PID del processo da aspettare, e l'ultimo argomento rappresenta opzioni che attraverso 
delle flag che possono essere unite mettendole in or tra di loro. 

\subsection{Esercizio 7}

Write a program that creates a child process, and then in the child closes standard output \verb|STDOUT FILENO|. 
What happens if the child calls \verb|printf()| to print some output after closing the descriptor?


\inputminted[firstline=1, lastline=4]{c}{./"Esercitazione del 29-10-24"/domanda7.c}
\inputminted[firstline=11, lastline=17]{c}{./"Esercitazione del 29-10-24"/domanda7.c}

Il processo figlio avendo chiuso lo standard output non è più in grado di stampare a schermo. 

\clearpage

\section{Gestione della Memoria}

\subsection{Allocazione di Memoria Dinamica}

Scrivi un programma che crea un array dinamico di numeri interi di dimensione specificata dall'utente, riempie l'array con numeri casuali e stampa l'array. Assicurati di liberare la memoria allocata alla fine del programma. 

\inputminted[firstline=1, lastline=4]{c}{./"Esercitazione del 19-11-24"/domanda1.c}
\inputminted[firstline=20, lastline=32]{c}{./"Esercitazione del 19-11-24"/domanda1.c}

Il programma richiedere un input dall'utente, e crea un array di dimensione 
pari a questo valore, riempito con interi di valore massimo pari a questo valore. Viene allocata memoria con \verb|malloc()| e liberata con \verb|free()|. 

La funzione \verb|printArray()| è utilizzata per verificare queste aggiunte, e verrà 
usata nei successivi esercizi:
\inputminted[firstline=12, lastline=18]{c}{./"Esercitazione del 19-11-24"/domanda1.c}

\subsection{Gestione di Vettori Dinamici}

Implementa una struttura dati per un vettore dinamico di interi. Includi funzioni per aggiungere un elemento, rimuovere un elemento e stampare tutti gli elementi del vettore. Assicurati che il vettore aumenti la sua capacità quando necessario. 

Questo si realizza introducendo una struttura dati contenente un array \verb|v|, la dimensione 
attuale dell'array \verb|l|, e la dimensione massima per la memoria allocata di \verb|v|, \verb|lmax|:

\inputminted[firstline=1, lastline=5]{c}{./"Esercitazione del 19-11-24"/domanda2.c}
\inputminted[firstline=13, lastline=17]{c}{./"Esercitazione del 19-11-24"/domanda2.c}

Si definiscono quindi le funzioni di creazione del vettore, aggiunta di un 
elemento e rimozione di un elemento, dato un indice. 

\inputminted[firstline=21, lastline=29]{c}{./"Esercitazione del 19-11-24"/domanda2.c}
Per l'aggiunta se viene raggiunta la dimensione massima dell'array, allora viene 
re-allocato su una zona di memoria di dimensione doppia, avendo un inserimento 
ammortizzato a tempo costante. Si utilizza quindi la funzione \verb|realloc()|:
\inputminted[firstline=33, lastline=40]{c}{./"Esercitazione del 19-11-24"/domanda2.c}
Per la rimozione si effettua prima un controllo sull'indice e si effettua uno shift 
di una posizione verso sinistra di ogni elemento successivo all'indice dato, e si 
decrementa la lunghezza dell'array \verb|l|:
\inputminted[firstline=43, lastline=51]{c}{./"Esercitazione del 19-11-24"/domanda2.c}

Nella funzione main si controlla il funzionamento generando un vettore di dimensione 
di default ed aggiungendo un numero di elementi casuali determinati dall'utente. In seguito si rimuove un elemento di indice selezionato. \inputminted[firstline=66, lastline=81]{c}{./"Esercitazione del 19-11-24"/domanda2.c} 
Si utilizza la funzione \verb|printArray()| precedente per stampare il vettore:
\inputminted[firstline=58, lastline=64]{c}{./"Esercitazione del 19-11-24"/domanda2.c}

\subsection{Manipolazione della memoria}

Scrivi un programma che alloca memoria per un array di interi, usa \verb|memset()| per impostare tutti gli elementi a zero, quindi usa \verb|memcpy()| per copiare il contenuto di un altro array nella memoria appena allocata.

\inputminted[firstline=1, lastline=5]{c}{./"Esercitazione del 19-11-24"/domanda3.c}
\inputminted[firstline=30, lastline=39]{c}{./"Esercitazione del 19-11-24"/domanda3.c}

La funzione \verb|memset()| prende come argomento un puntatore alla zona di memoria da 
modificare, il valore da assegnare ad ogni elemento, e la lunghezza per cui deve 
effettuare questo procedimento. Quindi potrebbe assegnare \verb|0| solamente ad una 
porzione dell'array se venisse specificato. La funzione \verb|memcpy()| copia nella 
zona di memoria passata come primo argomento la zona di memoria passata come 
secondo argomento, quindi è necessario che la funzione \verb|randArray()| restituisce un nuovo array. Inoltre come ultimo argomento prende una dimensione specificata per cui 
effettuare questa copia. Quindi anche per 
questa funzione è possibile copiare parzialmente una zona di memoria in un'altra. 

La funzione \verb|randArray()| restituisce un array contenente interi casuali, al massimo fino a \verb|dim|, di dimensione specificata. 
\inputminted[firstline=21, lastline=27]{c}{./"Esercitazione del 19-11-24"/domanda3.c}


\subsection{Implementazione di \texttt{my\_alloc()} e \texttt{my\_free()}}

In questo esercizio bisogna implementare il comportamento delle funzioni \verb|malloc()| e \verb|free()|, 
senza utilizzare queste due funzioni. Bisogna creare due funzioni una che dato un intero che indica il numero di byte 
da allocare, restituisce un puntatore di tipo \verb|void*| all'inizio della zona di memoria di dimensione passata. Ed un'altra funzione 
che prende un puntatore di tipo \verb|void*| ad una zona di memoria allocata e la libera. 

Quindi l'argomento della funzione \verb|my_alloc()| è il numero di byte della zona di memoria, di tipo \verb|size_t|, e 
restituisce un puntatore generico poiché non conosce il tipo di dati che sarà contenuto in questa 
zona di memoria. La funzione \verb|my_free()| dovrebbe prendere un puntatore ad un'area di memoria 
generica e restituisce un valore che indica se questa operazione è andata a buon fine o meno. 

Per implementare queste due funzioni si possono utilizzare una singola volta le funzioni \verb|mmap()| 
e \verb|munmap()|, durante l'esecuzione del programma. 
La prima funzione può essere utilizzata in due modi diversi, simulando il comportamento della malloc, 
poiché prende un numero di argomenti maggiore, permettendo comportamenti dati di default 
dalla malloc. Si possono definire i permessi dell'area di memoria da allocare, se è di sola 
lettura o scrittura, specificare se alcuni byte di quest'area possono essere eseguiti o indicare 
se questa zona può essere condivisa. \`{E} una funzione di più basso livello, con pià casi 
d'uso rispetto alla malloc, e si utilizza invece della malloc quando sono necessarie esigenze 
particolari. Un altro caso permette di creare una mappa con nome, un riferimento in memoria rispetto 
ad una file che si trova nel filesystem. Permette di semplificare il processo di interazione con 
un file nel filesystem, riservando un'area di memoria di dimensione pari a quella di questo file, con un certo offset opzionale. Si accede a questo file con la notazione array sulla zona di memoria che mappa il file. 

Se c'è una connessone diretta tra questa zona di memoria ed il file su disco, in base alle opzioni 
della funzione, è possibile modificare anche il file su disco. Questo tuttavia ha un costo 
sull'utilizzo della memoria, che potrebbe impedire il suo utilizzo, in caso la memoria virtuale 
necessaria è minore del file che si vuole mappare. Inoltre in base al file si potrebbe voler 
modificare o leggere una piccola porzione del file, quindi invece di effettuare una mappatura 
completa, è conveniente accedere normalmente al file senza trasferirlo in memoria. 
Si potrebbe creare mappe anonime, che non hanno un file corrispettivo nel filesystem, questo 
corrisponde all'esecuzione di una \verb|malloc()|, poiché non ha di default un file.  
La \verb|munmap()| è la controparte di questa funzione, permette di liberare un'area di memoria 
allocata utilizzando la funzione \verb|mmap()|. 

Accedendo alle pagine di manuale corrispondenti tramite il comando:
\begin{minted}{powershell}
corso@sistemi-operativi:~$ man map
\end{minted}
%$

Queste funzioni sono incluse nell'header \verb|sys/mman.h|. Il primo argomento della funzione è 
l'indirizzo di memoria che si vorrebbe avere come l'indirizzo di partenza della memoria 
allocata. Questa è un'opzione molto sofisticata, non necessaria per applicazioni così semplici, 
quindi si può inserire il valore \verb|NULL| per specificare che l'indirizzo di partenza della memoria non 
è rilevante, quindi è il kernel a scegliere automaticamente l'indirizzo, in modo che sia 
allineato con una pagina, ovvero ha un offset nullo per una pagina di memoria. 
Questo rappresenta solo un suggerimento, la funzione potrebbe non accettarlo e quindi dovrebbe 
sceglierlo il kernel nel modo precedentemente descritto. 

Un altro parametro di tipo \verb|site_t| specifica il numero di byte di questa zona di memoria da 
allocare. Altri due parametri chiamati \verb|prot| e \verb|flags| di tipo intero specificano 
opzioni di accesso e flag aggiuntive per l'operazione. Un altro parametro \verb|fd|, chiamato 
come un file descriptor, sempre di tipo intero, rappresenta il file che si vuole inserire in questa zona di memoria. Infine si può inserire un offset, per portare in memoria solamente una 
porzione del file, di tipo \verb|off_t|. 

Per i parametri \verb|prot| si possono utilizzare diverse opzioni per 
specificare che le pagine possono essere eseguite, lette, scritte, oppure non sono 
accessibili:
\begin{itemize}
    \item \verb|PROT_EXEC|: Permette la sua esecuzione;
    \item \verb|PROT_READ|: Permette l'accesso in lettura;
    \item \verb|PROT_WRITE|: Permette l'accesso in scrittura;
    \item \verb|PROT_NONE|: Non permette nessuna della precedenti. 
\end{itemize}
Queste operazioni possono essere messe in or per utilizzare più opzioni 
contemporaneamente. Per il parametro \verb|flags| sono possibili molte opzioni, le 
più interessanti per questo caso sono le opzioni per condividere la mappa ad altri processi, oppure per renderla privata ad un singolo processo:
\begin{itemize}
    \item \verb|MAP_PUBLIC|: La mappatura è accessibile da altri processi;
    \item \verb|MAP_PRIVATE|: La mappatura non è accessibile ad altri processi;
    \item \verb|MAP_ANONYMOUS|: La mappatura non richiede un file.
\end{itemize} 
Se si utilizza le opzioni \verb|prot| per scrivere e leggere, e si indica con il parametro \verb|flags| che si tratta di una mappa privata, il comportamento di questa funzione è analogo al 
comportamento di una \verb|malloc()|. 
Si utilizza un'ulteriore flag per indicare che si vuole creare una mappa anonima, senza 
specificare il file descriptor per il file su cui si vuole operare. Con questa flag il parametro 
\verb|fd| viene ignorato, e convenzionalmente viene inserito il valore -1. 
Queste funzioni appartengono allo standard POSIX, su molti sistemi operativi basati sul kernel Linux, e sono in accordo rispetto a delle interfacce e prototipi di funzioni, che possono 
avere implementazioni anche molto differenti l'una con l'altra. Quindi in alcune implementazioni, è richiesto che \verb|fd| sia uguale a -1. Dato che l'offset non viene utilizzato si pone pari a zero. La chiamata alla funzione \verb|mmap()| è quindi:
\inputminted[firstline=32,lastline=33]{c}{./"Esercitazione del 19-11-24"/domanda4.c}

Per la \verb|munmap()| si hanno due argomenti, l'indirizzo di base della mappa che si vuole 
rimuovere, e come secondo argomento si prende la dimensione della zona di memoria da liberare. La funzione \verb|free()| non ha bisogno di questo parametro, ma identifica automaticamente la 
dimensione della zona di memoria. Non appare a questo livello l'informazione necessaria per liberare l'area di memoria. 
Ciò avviene poiché alla chiamata di una \verb|malloc()|, poco prima dell'indirizzo restituito 
inserisce dei metadati relativi alla memoria che ha allocato, come la sua dimensione in byte. 
Questa dimensione viene letta ad un'eventuale \verb|free()| ed è quindi in grado di liberare 
esattamente la memoria precedentemente allocata. 

Per utilizzare una singola volta nell'intero programma queste due funzioni, un possibile approccio consiste nel realizzare una prima chiamata alla \verb|mmap()| generando una grande 
area di memoria, utilizzabile poi nel resto del programma. Inserendo direttamente la \verb|mmap()| dentro la \verb|my_alloc()| comporterebbe multiple chiamata alla \verb|mmap()|, ogni volte 
che viene effettuata una nuova allocazione. Questo essenzialmente aggira il problema, come se 
fosse inserita una \verb|malloc()| all'interno della funzione \verb|my_alloc()|. 


Si utilizza una funzione per allocare questa zona di memoria. Su questa zona per allocare 
una porzione di memoria, in modo che la \verb|my_free()| sia in grado di liberarla, bisogna 
implementare un meccanismo analogo alla \verb|free()|, inserendo un header per salvare metadati 
relativi alla memoria richiesta. Si realizza una struttura dati di tipo \verb|block| contenente la dimensione del blocco di memoria che segue il metadato, una variabile che 
indica se il blocco è libero ed il suo successivo blocco di memoria:
\inputminted[firstline=21,lastline=26]{c}{./"Esercitazione del 19-11-24"/domanda4.c}
Inizialmente questa zona di memoria rappresenta un intero blocco, contenente nei primi 16 byte un puntatore al relativo \verb|block| contenente i metadati. 
%% TODO img zona di memoria allocata
Quando si effettua una chiamata alla \verb|my_alloc()| di dimensione minore della memoria 
allocata, ma abbastanza grande da impedire la creazione di un altro blocco di memoria, poiché sono richiesti almeno 16 byte per memorizzare solamente i metadati in \verb|block*|. L'indirizzo restituito dalla \verb|my_alloc()| è la posizione iniziale sommata ai 16 byte dei metadati. 
%% TODO img zona di memoria completamente occupata (rimanenti < 16)
La funzione \verb|my_free()| prende un indirizzo base, torna indietro di 16 byte, e legge il 
blocco dei metadati, impostando ad uno il parametro \verb|free| della struttura, in modo che sia 
di nuovo utilizzabile. 

Se si effettua un'allocazione di dimensione più piccola, allora è possibile realizzare un nuovo 
blocco di questa memoria creando un nuovo \verb|block|, contenuto subito la zona più piccola 
allocata. In questo modo si divide il blocco iniziale in due, dove il primo avrà come metadato \verb|size| la dimensione attuale e come parametro \verb|next| l'indirizzo del successivo blocco. Questo blocco successivo avrà come metadato \verb|size| la dimensione rimanente della 
memoria allocata libera. 
%% TODO img zona di memoria divisa in blocchi, uno occupato
Ma quando viene liberato il primo blocco di memoria, saranno presenti due blocchi di memoria 
entrambi liberi, che dividono lo spazio totale. Questo può impedire allocazioni più grandi della 
dimensione di questi blocchi, nonostante complessivamente lo spazio totale possa contenerle. 

Questo rappresenta il memoria della frammentazione interna, per risolverlo al completamento di 
una \verb|my_free()| bisogna provare ad effettuare un unione tra blocchi liberi adiacenti, controllando dal blocco successivo nel parametro \verb|next| dei metadati, se anch'esso è libero. Continuando nei blocchi successivi fino a quando non si incontra un blocco occupato. 

Nonostante questo è possibile una frammentazione dove due blocchi di memoria libera sono divisi 
da un blocco occupato. 
%% TODO img zona di memoria tre blocchi iniziale e finale liberi, in mezzo occupato

Bisogna effettuare un'operazione di deframmentazione spostando i blocchi nella zona, ma in questo 
scenario non è possibile effettuarlo poiché non si sta programmando a livello del kernel, quindi 
l'effetto sarà non trasparente al livello del programmatore. Dopo aver spostato un blocco 
ed unito i due liberi, l'indirizzo di memoria del blocco occupato cambia, e non sarà più possibile 
accedervi tramite l'indirizzo fornito dalla precedente chiamata alla \verb|my_alloc()|. All'interno del sistema operativo sarebbe sufficiente modificare le istanze della page table per 
rendere questo cambiamento invisibile al programmatore, mantenendo la funzionalità dell'indirizzo 
fornito dalla \verb|my_alloc()|. 


All'inizio del programma si definiscono due macro, una per la dimensione della memoria, e la seguente per la dimensione minima di un blocco: 
\inputminted[firstline=7,lastline=8]{c}{./"Esercitazione del 19-11-24"/domanda4.c}
Si inizializzano due variabili puntatore a blocco per lo spazio di memoria e per la lista 
dei blocchi liberi:
\inputminted[firstline=27,lastline=28]{c}{./"Esercitazione del 19-11-24"/domanda4.c}

La prima funzione inizializza lo spazio di memoria, chiamando un'unica volta nell'intero programma la funzione \verb|mmap()|, controllando se ha fallito l'esecuzione ed inizializzando 
i valori dei metadati che si sta creando. 
\inputminted[firstline=30,lastline=44]{c}{./"Esercitazione del 19-11-24"/domanda4.c}

Si definisce in seguito l'operazione per suddividere dei blocchi, dato un riferimento ad un blocco \verb|block| e la dimensione della memoria occupata nel blocco \verb|size|, inserendo in coda il nuovo blocco.  
Il puntatore di base del nuovo blocco si ottiene dall'indirizzo del blocco, sommando la dimensione della memoria da occupare passata come parametro \verb|size| e la dimensione del blocco. La dimensione di questo nuovo blocco è la dimensione rimasta, dopo aver rimosso dalla dimensione corrente del blocco la dimensione dei dati che si sta inserendo \verb|size| e la dimensione del blocco. Lo stato di questo nuovo blocco è libero ed ha come successivo, il blocco 
successivo del corrente. Si aggiornano in fine i metadati del blocco passato, inserendo come successivo questo nuovo blocco. 
\inputminted[firstline=47,lastline=56]{c}{./"Esercitazione del 19-11-24"/domanda4.c}


Un'ulteriore funzione stampa il layout della memoria in un dato momento, ogni volta che viene 
chiamata un'allocazione o de-allocazione. 

Segue la definizione della \verb|my_alloc()|, rifiuta richieste di allocazioni dove la dimensione passata è minore o uguale a zero, poiché si tratta di una richiesta sbagliata. In seguito chiama \verb|init_memory_pool()|, per creare se non è mai stata creata la zona di memoria. 
In seguito scorre la \verb|free_list| cercando un blocco libero, di dimensione maggiore della richiesta. Se viene trovato, si controlla se è possibile frammentarlo, ed in caso viene chiamata la \verb|split_blocks()|, altrimenti semplicemente si assegna il blocco corrente come occupato. 
In seguito viene restituito l'indirizzo di partenza della memoria allocata, aggiungendo la dimensione del blocco all'indirizzo del blocco corrente. 
Se non viene individuato alcun blocco viene restituito \verb|NULL|, poiché si è esaurita la memoria di dimensione maggiore della dimensione specificata. 
\inputminted[firstline=70,lastline=89]{c}{./"Esercitazione del 19-11-24"/domanda4.c}

In seguito si definisce la funzione per unire tra loro due blocchi, quando si trovano due nodi 
liberi adiacenti, scorrendo la lista. 
\inputminted[firstline=91,lastline=96]{c}{./"Esercitazione del 19-11-24"/domanda4.c}
Quest'implementazione permette l'unione di blocchi adiacenti, controllando solamente a destra, se fossero presenti dei blocchi liberi alla sinistra, non verrebbero uniti tra di loro. 


Per realizzare la \verb|my_free()| si passa un puntatore, e si ottiene l'indirizzo al blocco corrispondente, sottraendo la dimensione di un blocco. Si aggiornano i suoi metadati e si tenta di unire blocchi liberi, chiamando la \verb|merge_blocks()| sul blocco corrente:
\inputminted[firstline=98,lastline=107]{c}{./"Esercitazione del 19-11-24"/domanda4.c}

Si definisce infine la funzione per liberare la memoria al termine del programma:
\inputminted[firstline=109,lastline=116]{c}{./"Esercitazione del 19-11-24"/domanda4.c}

\clearpage

\section{Programmazione Concorrente}

\subsection{Moltiplicazione tra Matrici}

Se un problema è parallelizzabile e si può implementare utilizzando thread con una qualsiasi libreria, non necessariamente \verb|pthread|. Se è presente un'architettura multicore o multiprocessore, allora è molto probabile rendere più veloce 
l'esecuzione del programma, ottenendo prestazioni migliori.  


Si considera un programma in grado di effettuare la moltiplicazione tra due matrici riempite di interi casuali. Si ha una macro che definisce una dimensione massima per 
la matrice bidimensionale e si definiscono tre matrici in variabili globali. 
Una prima funzione riempie le matrici in modo casuale:
\inputminted[firstline=1, lastline=15]{c}{./"Programmazione Concorrente"/single.c}
Un ulteriore funzione effettua questa moltiplicazione, in modo seriale:
\inputminted[firstline=17, lastline=24]{c}{./"Programmazione Concorrente"/single.c}

Nella funzione main si inizializzano queste due matrici. Inoltre si utilizza una funzione per in-strumentare il codice ed ottenere statistiche, in questo caso 
riguardanti i tempi di esecuzione. Si può utilizzare la funzione \texttt{gettimeofday()}, più precisa rispetto alla funzione \verb|time()|, 
che restituisce il valore in una variabile di tipo \verb|time_val| del tempo corrente. Questa struttura contiene un campo contenente il time stamp, ed un'altra porzione che 
contiene il valore in microsecondi al momento dell'esecuzione della funzione. 
\verb|time()| invece ha intervalli di tempo in secondi, e non ha informazioni sul 
tempo in microsecondi. 

Intorno alla funzione di cui vogliamo conoscere queste statistiche sono presenti 
due chiamata alla funzione descritta, salvando i loro valori in due variabili diverse. 
In seguito si effettua una somma sulla stessa scale per determinare il tempo effettivo 
dell'esecuzione:
\inputminted[firstline=26, lastline=42]{c}{./"Programmazione Concorrente"/single.c}


Per svolgere questo programma sfruttando la 
programmazione concorrente, si utilizzano un certo numero di thread assegnati ad un certo numero di righe della matrice. 
Si realizza una struttura dati per contenere le informazioni relative ad i thread, e 
si assegna un certo numero di thread:
\inputminted[firstline=1, lastline=19]{c}{./"Programmazione Concorrente"/multi.c}

Il calcolo del prodotto tra matrici avviene quindi sui sottoinsiemi del problema 
contenuti nella struttura di tipo \verb|ThreadData|: 
\inputminted[firstline=27, lastline=36]{c}{./"Programmazione Concorrente"/multi.c}

Il problema viene diviso su questi thread, associando ad ognuno di questi thread un 
sottoinsieme delle righe della matrice originaria: 
\inputminted[firstline=42, lastline=44]{c}{./"Programmazione Concorrente"/multi.c}

L'unica altra modifica rispetto al programma seriale è la presenza di un ciclo 
tra le due \verb|gettimeofday()|, dove vengono avviati tutti i thread, inizializzando 
le loro strutture \verb|thread_data|, ed un altro ciclo per effettuare un join su 
ognuno di questi thread:
\inputminted[firstline=50, lastline=63]{c}{./"Programmazione Concorrente"/multi.c}



Ci si aspetta che il tempo di esecuzione 
di questo programma sia velocizzato di un fattore pari al numero di thread, ma essendo presenti overhead, ed in generale nell'esecuzione di 
un qualsiasi programma parallelizzabile, non è possibile raggiungere questo incremento ideale. 
In questo caso inoltre il programma viene eseguito in un container docker quindi ha uno stack molto profondo, è quindi difficile ottenere le prestazioni volute. Utilizzando il comando \verb|top|, durante l'esecuzione di questa funzione mostra come le percentuali di utilizzo della CPU 
sono del 400\%, poiché rappresenta la somma dell'utilizzo di ogni core del processore, avendo 
quattro thread è quindi quattro volte l'utilizzo del programma seriale. 


Essendo eseguito all'interno di un container docker, il risultato di questa esecuzione dipende dalla configurazione corrente. In caso il numero di core disponibili è minore del numero di thread descritti in questo file è necessario modificare la configurazione di docker. 
Nella Home directory è presente un file chiamato \verb|.wslconfig| che specifica le risorse da assegnare, contiene un nome che indica la configurazione tra 
parentesi quadre, e due parametri \verb|memory| e \verb|processors|, questi se sono commentati indicano il valore di default:
\begin{minted}{c}
    [wsl2]
    #memory=4GB
    processors=4
\end{minted}
Se non è presente è possibile 
crearlo con il nome della configurazione \verb|[wsl2]|. In versioni successive di docker è possibile modificare questi valori con un'interfaccia grafica 
tra le impostazioni di docker. 
Per aggiornare questi valori bisogna terminare il container ed eseguire il comando \verb|wsl --shutdown| per riavviare l'engine wsl con le relative configurazioni. 
Il tempo di esecuzione diminuendo il numero di core disponibili è migliore rispetto al programma non parallelizzato, ma decisamente peggiore rispetto alla configurazione 
con più core. Se si modifica il codice del programma per rendere il numero di thread pari al numero di core disponibili allora è possibile aumentare leggermente il 
tempo di esecuzione. 

In applicazioni di cloud computing, dove sono presenti un numero molto elevato di core, generalmente le macchine virtuali disponibili utilizzano un numero di core maggiore 
di una divisione equa, poiché è improbabile che tutte le macchine virtuali utilizzino allo stesso tempo tutti i core presenti. Questo meccanismo di over-provisioning o sovradimensionamento permette di aumentare le prestazioni delle macchine virtuali 
presenti, permettendole di operare con più risorse di quante siano le risorse fisiche 
disponibili. Questa tecnica può essere effettuata anche sulla memoria principale o 
secondaria per ogni macchina virtuale. 


\subsection{Modello Consumatori e Produttori}

Un'architettura software molto usata è costituita da un agente produttore che realizza un certo tipo di informazione ed un consumatore che utilizza quest'informazione. 
Condividono una qualche struttura dati per condividere quest'informazione, accessibile ad entrambi gli agenti. Questo rappresenta un problema di sincronizzazione tra i due, tra i più classici e rappresenta un'architettura di base per sistemi moderni, per 
realizzare applicazioni moderni, come applicazioni basate su microservizi. 



Una pila di 10 elementi interi è condivisa tra due thread: un produttore ed un consumatore. 
\begin{enumerate}
    \item Il produttore deve essere implementato secondo la seguente logica. In un ciclo infinito:
    \begin{itemize}
        \item Deve attendere una quantità di tempo casuale inferiore al secondo;
        \item Una volta scaduta l'attesa, se la pila è piena, deve attendere che qualche elemento venga rimosso dal consumatore;
        \item Quando si libera dello spazio nello stack, deve inserire un numero casuale di elementi (senza andare in overflow).
    \end{itemize}
    \item Il consumatore deve essere implementato secondo la seguente logica. In un ciclo infinito:
\end{enumerate}
Deve attendere una quantità di tempo casuale inferiore al secondo
Una volta scaduta l'attesa, se lo stack è vuoto, deve attendere che qualche elemento venga inserito dal produttore
Quando lo stack non è vuoto, deve leggere un numero casuale di elementi, inferiore o uguale al numero di elementi presenti nello stack.
Suggerimenti:
\begin{itemize}
    \item Lo stack può essere implementato con un array di interi, un contatore di elementi già inseriti, e con due funzioni: \verb|push()| e \verb|pop()|;
    \item Alcune funzioni utili: \verb|random()| e \verb|usleep()|.  
\end{itemize}

Si realizza una struttura dato chiamata \verb|stack| che rappresenta la pila, 
contenente un array di interi, un intero che indica la dimensione complessiva, ed un 
ulteriore intero che specifica il numero di posizioni occupate nella pila:
\inputminted[firstline=1, lastline=14]{c}{./"Programmazione Concorrente"/consumatore_produttore.c}
Si realizza una variabile globale 
pila, poiché è l'unica struttura dati utilizzata nel problema. 

Si definiscono quindi le operazioni di inizializzazione della pila, di inserimento e rimozione 
in coda:
\inputminted[firstline=16, lastline=36]{c}{./"Programmazione Concorrente"/consumatore_produttore.c}
A differenza della funzione \verb|malloc()|, la funzione \verb|calloc()| inizializza 
tutti i valori della zona di memoria allocata a zero. Le funzioni di pop e 
push incluse sono semplificate, si utilizza il valore -1 di default per indicare 
che l'operazione di pop è stata eseguita su di una pila vuota, anche se questa dovrebbe 
poter gestire interi negativi. 

Per poter gestire questi due agenti, bisogna creare due thread, assegnati a due funzioni 
diverse, una consumatore ed un'altra produttore. Per cui queste due funzioni devono 
restituire una variabile di tipo puntatore a void, ed accettano un argomento 
di tipo puntatore a void. 
Si potrebbe realizzare anche con una fork, ma lo spazio di memoria non sarebbe 
condiviso e quindi il problema sarebbe più difficile, poiché ogni inserimento 
o rimozione deve essere effettuato su una terza zona di memoria condivisa 
oppure su di un file. La programmazione multi-processo è quindi 
tendenzialmente più difficile di una programmazione multithread, poiché sono 
necessarie più funzioni del sistema operativo per realizzare le stesse 
operazioni. 

Il produttore itera su un ciclo infinito ed aspetta un intervallo di tempo 
casuale, fornito da \verb|usleep()| passando come argomento un intero 
casuale fino a $10^6$, poiché l'unità di misura è in microsecondi. 
Bisogna effettuare un cast di \verb|1e6|, poiché è di tipo \verb|double| e non 
è compatibile con l'operatore modulo. Bisogna stabilire 
quanti elementi da inserire in pila, devono essere in numero inferiore o uguale 
al numero di posizioni disponibili. Dato questo numero si 
itera e si inseriscono dei numeri casuali invocando la funzione \verb|push()|. 
Bisogna inserire un controllo, per verificare se il consumatore deve consumare 
elementi dalla pila. Per impedire di ripetere continuamente questo ciclo 
su una pila piena, si attende fino a quando non si libera dello spazio, 
con un'istruzione condizionale. 
Il consumatore si implementa analogamente, con un ciclo infinito, che 
attende per un tempo casuale, e legge nella pila solamente se non è vuota. 

Si inseriscono inoltre delle stampe per indicare le operazioni eseguite 
da questi due agenti. 

Si inizializza la pila e si definiscono le due variabili contenenti 
i thread. 
Per implementare queste queste due funzioni come due thread si creano 
con la funzione \texttt|pthread\_create()|. Non bisogna specificare né il 
secondo né il quarto parametro di questa funzione, poiché non si sono 
opzioni da specificare o il numero di worker. Come primo parametro si 
inserisce il puntatore al thread, e come terzo la funzione da eseguire. 

A questo punto l'esecuzione di questo programma non produce nulla, poiché il thread 
principale termina prima dell'esecuzione di questi due thread, terminando 
anche loro. 
Il thread principale deve attendere la terminazione dei figli, ma questi 
eseguono un ciclo infinito quindi non finiranno mai, bisogna essere 
consapevoli di questo, poiché il programma deve essere terminato con la 
sequenza ``Ctrl + C''. Si utilizza la funzione \verb|pthread_join()|, 
specificando come primo parametro i thread di cui bisogna aspettare l'esecuzione 
ed un parametro nullo:
\inputminted[firstline=70, lastline=79]{c}{./"Programmazione Concorrente"/consumatore_produttore.c} 
Questi due thread possono accedere alla stessa area di memoria 
contemporaneamente e quindi bisogna inserire un lock per impedire che 
tentino di effettuare contemporaneamente operazioni sulla pila. 

Per inserire questo lock si utilizzano due funzioni \verb|lock()| 
e \verb|unlock()|, passando come argomento un riferimento alla struttura dati 
che si vuole bloccare. Si avrà quindi per il produttore:
\inputminted[firstline=38, lastline=53]{c}{./"Programmazione Concorrente"/consumatore_produttore.c}
E per il consumatore:
\inputminted[firstline=55, lastline=67]{c}{./"Programmazione Concorrente"/consumatore_produttore.c}

\subsection{Esercitazione del 3 Dicembre}

Un file su disco ha il seguente formato:
\begin{minted}{html}
    <numero_record><record 1><record 2>...
\end{minted}
Dove: 
\begin{itemize}
    \item \verb|<numero_record>| è un intero rappresentante il numero di record attualmente presenti all'interno del file;
    \item \verb|<record1><record2>...| sono ognuno un numero intero.
\end{itemize}
Il file è acceduto da due thread: un produttore ed un consumatore, ed è gestito come se fosse una pila: i nuovi elementi vengono accodati al termine del file, e la lettura (con contestuale rimozione) degli elementi avviene dall'ultimo elemento del file. Il file non deve contenere più di 10 record oltre all'indicatore iniziale del numero di record presenti.

I due thread, produttore e consumatore, hanno il seguente comportamento:
\begin{enumerate}
    \item Il produttore, in un ciclo infinito:
    \begin{enumerate}
        \item Deve attendere una quantità di tempo casuale inferiore al secondo;
        \item Una volta scaduta l'attesa, se la pila contenuta nel file è piena, deve attendere che qualche elemento venga rimosso dal consumatore;
        \item Quando si libera dello spazio nella pila, deve inserire un numero casuale di elementi (senza andare in overflow rispetto alle dimensioni della pila) ed aggiornare il contatore all'inizio del file.
    \end{enumerate}
    \item Il consumatore, in un ciclo infinito:
    \begin{enumerate}
        \item Deve attendere una quantità di tempo casuale inferiore al secondo;
        \item Una volta scaduta l'attesa, se la pila è vuota, deve attendere che qualche elemento venga inserito dal produttore;
        \item Quando la pila non è vuota, deve leggere un numero casuale di elementi (inferiore o uguale al numero di elementi presenti nello stack), sostituirne il valore con il numero 0 ed aggiornare il valore all'inizio del file.
    \end{enumerate}
\end{enumerate}

Suggerimento:

Quando si esegue una \verb|read()| o una \verb|write()| su un file, viene spostato un cursore in avanti del numero di byte letti o scritti sul file. Ad esempio, se un file contenesse la stringa ``ciaopino'' e venisse effettuata una \verb|read()| di 4 byte, questa leggerebbe ``ciao''. Un'eventuale seconda \verb|read()| di 4 byte leggerebbe invece ``pino''. Allo stesso modo, se si eseguisse una prima lettura di 4 byte e successivamente una scrittura di 4 byte della stringa ``anno'', il file conterrebbe la stringa ``ciaoanno'' al termine dell'esecuzione delle \verb|read()| e delle \verb|write()|.
\`{E} possibile spostare il cursore anche senza necessariamente effettuare una \verb|read()| o una \verb|write()|, utilizzando la funzione \verb|lseek()|, usa il manuale per scoprire come usare \verb|lseek()|.

\end{document}